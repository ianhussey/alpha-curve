---
title: "A excess of Cronbach's Œ± values at rule-of-thumb cut-offs"
subtitle: "Process psycTests dataset"
author: "Ian Hussey, Ruben Arslan, & Taym Alsalti"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999)
```

# Dependencies

```{r}

library(tidyverse)
library(patchwork)
library(scales)
library(ggtext)

records_wide <- read_rds("../../data/raw/psycTests/preprocessed_records.rds") |>
  mutate(Reliability = str_to_lower(Reliability))

```

# Extract strings from psychTest records

## Define regex

```{r}

regex_string             <- "([a-zA-Z]|[\\(,\\),0,=+]| )\\.[0-9]{2,}"
regex_string_subset      <- "\\.\\d*"
regex_string_doi         <- "\\.[0-9]{1,}\\.[0-9]{1,}"

```

### Tests

Test some of the regex that is used below. NB leading spaces in strings don't print correctly.

Repeat estimates only return the first estimate.

```{r}

regex_tests <- 
  tibble(string = c("in the current sample was 0.70", "= 0.70", "= .70", "=.70", " 0.70", " .70", "alpha of.70", "alphas of .70 and .80", "(.70)", "0.7", "-0.7", "-.7", "section 2.70", "doi 0.0.70", ". 70"),
         required_result = c(".70", ".70",".70",".70",".70",".70",".70",".70", ".70", NA, NA, NA, NA, NA, NA)) |>
  mutate(
    result = str_extract(str_extract(string, regex_string), regex_string_subset),
    #result = str_extract(string, regex_string),
    test_passed = if_else(result == required_result | (is.na(result) & is.na(required_result)), TRUE, FALSE, FALSE)
  )

regex_tests

```

## Extract strings

```{r}

records_wide_modified <- records_wide %>% 
  mutate(
    no_reliability = Reliability == "No reliability indicated.",
    Reliability = str_replace_all(Reliability, "[[:space:]]+", " "),
    first_reliability_match = as.numeric(str_extract(str_extract(Reliability, regex_string), regex_string_subset)),
    all_reliabilities = str_extract_all(Reliability, regex_string) %>% map(~ str_extract(., regex_string_subset)) %>% map(as.numeric),
    reliability_mentions_alpha = str_detect(string = Reliability, pattern = "(cronbach('|‚Äô)?s? (alpha|Œ±|a)|(coefficient) (alpha|Œ±|a =|a=))"),
    reliability_mentions_internal_consistency = str_detect(string = Reliability, pattern = "internal consistenc"),
    reliability_mentions_p_value = str_detect(string = Reliability, pattern = "(\\bps? ?(<|=|>) ?\\d+|p ?<|p ?=)"),
    reliability_mentions_loadings_or_item_correlations = str_detect(string = Reliability, pattern = "(loadings?|item-total correlation|inter-item correlation)"),
    reliability_mentions_nunnally = str_detect(string = Reliability, pattern = "nunn?all?y"),
    reliability_mentions_threshold = str_detect(string = Reliability, pattern = "threshold"),
    reliability_mentions_test_retest = str_detect(string = Reliability, pattern = "test(/|-| )retest (reliability|stability|correlation)"),
    reliability_mentions_omega = str_detect(string = Reliability, pattern = "omega|œâ"),
    reliability_mentions_split_half = str_detect(string = Reliability, pattern = "split(-| )half"),
    reliability_mentions_interrater = str_detect(string = Reliability, pattern = "interrater reliability"),
    reliability_mentions_pearson = str_detect(string = Reliability, pattern = "(pearson product-moment correlation|pearson's correlation|pearson correlation|product-moment correlation|pearson's r)"),
  ) %>% 
  rowwise() |>
  mutate(locations = list(
    as.data.frame(
      str_locate_all(string = Reliability, pattern = regex_string)
    ) |>
      rownames_to_column(var = "exemplar")
  )) |>
  ungroup()



pre_window_size <- 50

non_cron <- c(
  "p\\s*-?\\s*value", # p-values
  "(load(|s|ed|ing|ings)|item-total correlation|inter-?item)", # loadings
  "(test(/|-| ))?retest", # retest,
  "split(-| )half", # split half
  "(icc|intraclass)", # ICC
  "inter-?rater", # interrater
  "\\b(congruenc[ey])\\b", # congruence reliability/coefficient (harman 1976)
  # "(kr-reliabilit|kuder|k-r-reliabilit)", # kuder-richardson
  "(spearman)", # spearman
  "(minimally important change|mic)", # MIC values
  "omega|œâ", 
  "(\\bŒ∫\\s*\\(\\d+\\)\\s*[=<>‚â•‚â§]|\\bŒ∫\\s*[=<>‚â•‚â§]|\\bkappa\\s*\\(\\d+\\)\\s*[=<>‚â•‚â§]|\\bkappa\\s*[=<>‚â•‚â§])", # Œ∫/kappa 
  "(\\bœÅ\\s*\\(\\d+\\)\\s*[=<>‚â•‚â§]|\\bœÅ\\s*[=<>‚â•‚â§]|\\broh\\s*\\(\\d+\\)\\s*[=<>‚â•‚â§]|\\broh\\s*[=<>‚â•‚â§])",  # œÅ/roh
  "(\\bp\\s*\\(\\d+\\)\\s*[=<>‚â•‚â§]|\\bp\\s*[=<>‚â•‚â§])", # p-value,
  "(\\br\\s*\\(\\d+\\)\\s*[=<>‚â•‚â§]|\\br\\s*[=<>‚â•‚â§]|\\bùëü\\s*\\(\\d+\\)\\s*[=<>‚â•‚â§]|\\bùëü\\s*[=<>‚â•‚â§])", # r/ùëü
  "composite reliabilit(y|ies)", 
  "(item reliabilit(y|ies)|person reliabilit(y|ies))",
  "inter-?correlation", # item intercorrelation
  "(person separat(e|ion) index|psi)", # person separate index
  "(correlat(e|es|ed|ion|ions))" # correlation of any kind
)

non_crons <- paste0("(", non_cron, ")", collapse = "|")

# we extract chunks of text that signify the text is about reliability

```

```{r}

### 1
data_extracted_cronbach_alpha <- records_wide_modified %>% 
  select(doi = DOI, text = Reliability) |>
  rowwise() |>
  mutate(locations = list(
    as.data.frame(
      str_locate_all(string = text, pattern = "(cronbach('|‚Äô)?s? (alpha|Œ±|a)|(coefficient) (alpha|Œ±|a =|a=))")
    ) |>
      rownames_to_column(var = "exemplar")
  )) |>
  ungroup() |>
  unnest(locations) |>
  rename(location_start = start, 
         location_end = end) |>
  mutate(pre  = str_sub(text,
                        start = location_end - pre_window_size,
                        end   = location_end - 1),
         different_stat_mention = location_end + str_locate(str_sub(text,
                                                                    start = location_end), non_crons)[,"end"],
         post = str_sub(text, start = location_end,
                        end = coalesce(
                          different_stat_mention,
                          str_length(text))),
         all = ifelse(!is.na(pre) & !is.na(post), paste(pre, post, sep = ""), NA),
         regex_label = "cronbach's alpha",
         regex_inclusion = "(cronbach('|‚Äô)?s? (alpha|Œ±|a)|(coefficient) (alpha|Œ±|a =|a=))",
         regex_exclusion = "none") |>
  select(doi, 
         regex_label, regex_inclusion, regex_exclusion,
         exemplar, location_start, location_end, different_stat_mention,
         pre, post, all)
```

```{r}

### 2
data_extracted_consistency_or_reliability_and_alpha <- records_wide_modified %>% 
  #filter(DOI == "10.1037/t67763-000") %>% 
  select(doi = DOI, text = Reliability) |>
  # first find reference to internal consistency
  rowwise() |>
  mutate(locations = list(
    as.data.frame(
      str_locate_all(string = text, pattern = "(consistenc|(?<!interrater|retest|half).* reliabilit)")
    ) |>
      rownames_to_column(var = "exemplar")
  )) |>
  ungroup() |>
  unnest(locations) |>
  rename(location_start = start, 
         location_end = end) |>
  mutate(pre_ic  = str_sub(text,
                           start = location_end - pre_window_size,
                           end   = location_end - 1),
         different_stat_mention = location_end + str_locate(str_sub(text,
                                                                    start = location_end), non_crons)[,"end"],
         post_ic = str_sub(text, start = location_end,
                           end = coalesce(
                             different_stat_mention,
                             str_length(text)))) |>  
  # then find reference to alpha within the result
  rowwise() |>
  mutate(locations = list(
    as.data.frame(
      str_locate(string = post_ic, pattern = "(alpha|Œ±|a =|a=)")
    ) 
  )) |>
  ungroup() |>
  unnest(locations) |>
  rename(location_start_alpha = start, 
         location_end_alpha = end) |>
  mutate(
    location_start = location_end + location_end_alpha - 10,
    location_end = location_end + location_end_alpha - 1,
    pre  = str_sub(text,
                      start = location_end - 50,
                      end   = location_end - 1),
    post = str_sub(post_ic, 
                   start = location_end_alpha, 
                   end = location_end_alpha + 50),
    all = ifelse(!is.na(pre) & !is.na(post), paste(pre, post, sep = ""), NA),
    regex_label = "consistency|reliability, alpha, !cronbach",
    regex_inclusion = "c('consistenc|reliabilit', '(alpha|Œ±|a =|a=)')",
    regex_exclusion = "(cronbach('|‚Äô)?s?|coefficient)") |>
  filter(!str_detect(all, "(cronbach('|‚Äô)?s?|coefficient)")) |>
  select(doi, 
         regex_label, regex_inclusion, regex_exclusion, 
         exemplar, location_start, location_end, 
         pre, post, all)
```

```{r}

### 3
data_extracted_internal_consistency <- records_wide_modified %>% 
  select(doi = DOI, text = Reliability) |>
  # first find reference to internal consistency
  rowwise() |>
  mutate(locations = list(
    as.data.frame(
      str_locate_all(string = text, pattern = "internal (consistenc|reliabilit)")
    ) |>
      rownames_to_column(var = "exemplar")
  )) |>
  ungroup() |>
  unnest(locations) |>
  rename(location_start = start,
         location_end = end) |>
  mutate(pre  = str_sub(text,
                        start = location_end - pre_window_size,
                        end   = location_end - 1),
         different_stat_mention = location_end + str_locate(str_sub(text,
                                                                    start = location_end), non_crons)[,"end"],
         post = str_sub(text, start = location_end,
                        end = coalesce(
                          different_stat_mention,
                          str_length(text))),
         all = ifelse(!is.na(pre) & !is.na(post), paste(pre, post, sep = ""), NA),
         regex_label = "internal consistency|reliability, !alpha, !cronbach",
         regex_inclusion = "internal (consistenc|reliabilit)",
         regex_exclusion = "c('cronbach('|‚Äô)?s?', '(alpha|Œ±|a =|a=)')") |>
  select(doi,
         regex_label, regex_inclusion, regex_exclusion,
         exemplar, location_start, location_end,
         pre, post, all)

```

```{r}

# combine
data_extracted <-
  bind_rows(data_extracted_cronbach_alpha,
            data_extracted_consistency_or_reliability_and_alpha,
            data_extracted_internal_consistency)

```

# Extract estimates

## Extract using regex

```{r}

# exclude the estimates if they occur 10 characters after any of these, see substring_abit_before_estimate
# will detect parentheses between p,r etc. and value e.g., "r(sample size) = xx". 
non_cron_quant <- c( 
  "(\\bŒ∫\\s*\\(\\d+\\)\\s*[=<>‚â•‚â§]|\\bŒ∫\\s*[=<>‚â•‚â§]|\\bkappa\\s*\\(\\d+\\)\\s*[=<>‚â•‚â§]|\\bkappa\\s*[=<>‚â•‚â§])", # Œ∫/kappa 
  "(\\bœÅ\\s*\\(\\d+\\)\\s*[=<>‚â•‚â§]|\\bœÅ\\s*[=<>‚â•‚â§]|\\broh\\s*\\(\\d+\\)\\s*[=<>‚â•‚â§]|\\broh\\s*[=<>‚â•‚â§])",  # œÅ/roh
  "(\\bp\\s*\\(\\d+\\)\\s*[=<>‚â•‚â§]|\\bp\\s*[=<>‚â•‚â§])", # p-value,
  "(\\br\\s*\\(\\d+\\)\\s*[=<>‚â•‚â§]|\\br\\s*[=<>‚â•‚â§]|\\bùëü\\s*\\(\\d+\\)\\s*[=<>‚â•‚â§]|\\bùëü\\s*[=<>‚â•‚â§])" # r/ùëü
)
  
non_crons_quant <- paste0("(", non_cron_quant, ")", collapse = "|")


data_estimates <- data_extracted %>% 
  rowwise() %>% 
  mutate(locations = list(
    as.data.frame(
      str_locate_all(string = post, pattern = regex_string)
    ) |>
      rownames_to_column(var = "exemplar_alpha")
  )) |>
  ungroup() |>
  unnest(locations) |>
  rename(location_alpha_start = start,
         location_alpha_end = end) |> 
  mutate(
    # substrings
    substring_between_cronbach_and_estimate = str_sub(post, start = 1, end = location_alpha_start),
    substring_immediately_before_estimate = str_sub(post, start = location_alpha_start-3, end = location_alpha_start),
    substring_a_bit_before_estimate = str_sub(post, start = location_alpha_start-10, end = location_alpha_start),
    substring_immediately_after_estimate = str_sub(post, start = location_alpha_end, end = location_alpha_end+6),
    substring_a_bit_after_estimate = str_sub(post, start = location_alpha_end, end = location_alpha_end+14),
    alpha_string = str_sub(post, start = location_alpha_start, end = location_alpha_end),
    # exclusion variables
    exclude_quant_comparison_present = str_detect(substring_between_cronbach_and_estimate, "[<>‚â•‚â§¬±‚âà]"),
    exclude_comparison_present = str_detect(substring_between_cronbach_and_estimate, "([<>‚â•‚â§¬±‚âà]|\\bover\\b|larger|\\bexceed\\b|above|upper|greater|higher|\\bmore\\b|lower|below|bellow|smaller|\\bless\\b|at least|between|the order of|increase|decrease)"),
    exclude_comparison_present_immediately_after_estimate = str_detect(substring_immediately_after_estimate, "(to|‚Äì|‚àí|‚Äì|-|\\+)"),
    exclude_comparison_present_immediately_before_estimate = str_detect(substring_immediately_before_estimate, "(to|‚Äì|‚àí|‚Äì|-|\\+)"),
    exclude_comparison_present_before_estimate = str_detect(pre, "(bound(s)?|surpass|exceed|above|higher|more|greater|below|less|lower)"),
    exclude_comparison_present_after_estimate = str_detect(post, "(bound(s)?|surpass|exceed|or above|or higher|or more|or greater|or below|or less|or lower)"),
    exclude_s = str_starts(exclude_comparison_present_after_estimate, "s"), # eg "in the .70s"
    exclude_cutoff_present = str_detect(substring_between_cronbach_and_estimate, "cut(\\s|-|)off|criteri[oa]|threshold|minimum|reference value"),
    exclude_range_present = str_detect(substring_between_cronbach_and_estimate, "(range|ranging|between|from)"),
    exclude_nonalphas_present = str_detect(substring_between_cronbach_and_estimate, "(m ?=|sd ?=|se ?=|ci ?=)"),
    exclude_non_cron_mention_after_estimate = str_detect(substring_a_bit_after_estimate, non_crons),
    exclude_non_cron_mention_before_estimate = str_detect(substring_a_bit_before_estimate, 
                                                          non_crons_quant), 
    exclude_significance_present = str_detect(all, "(significan|type I|level|two-?tailed|one-?tailed|power|null hypothes|effect-?size|differ reliably)"),
    exclude_doi_present = str_detect(post, regex_string_doi),
    exclude_doi_string_present = str_detect(all, "doi"),
    exclude_CI = str_detect(substring_a_bit_before_estimate, paste0("(", regex_string, " \\(|\\(", regex_string, ",)")),
    # something about references to this journal keep getting confused for alpha values
    exclude_psychometrika_present = str_detect(substring_between_cronbach_and_estimate, "psychometrika"),
    exclude_odd_string_present = str_detect(substring_between_cronbach_and_estimate, " d s "),
    exclude_kappa = str_detect(all, "(kappa|Œ∫)"),
    # exclude_no_alpha = str_detect(all, alpha)
  ) |>
  mutate(
    # master exclusion variable
    exclude_master = ifelse(
      #alpha == "." |
      exclude_comparison_present == TRUE |
        exclude_comparison_present_immediately_after_estimate == TRUE |
        exclude_comparison_present_immediately_before_estimate == TRUE |
        exclude_comparison_present_before_estimate == TRUE |
        exclude_comparison_present_after_estimate == TRUE |
        exclude_cutoff_present == TRUE |
        exclude_range_present == TRUE |
        exclude_nonalphas_present == TRUE |
        exclude_non_cron_mention_after_estimate == TRUE |
        exclude_non_cron_mention_before_estimate == TRUE |
        exclude_significance_present == TRUE |
        exclude_doi_present == TRUE |
        exclude_doi_string_present == TRUE |
        exclude_CI == TRUE |
        exclude_psychometrika_present == TRUE |
        # exclude_no_alpha == FALSE |
        exclude_odd_string_present == TRUE |
        exclude_kappa == TRUE |
        exclude_s == TRUE,
      TRUE, 
      FALSE
    ),
    exclude_master = ifelse(is.na(exclude_master), TRUE, exclude_master),
    alpha_all = as.numeric(str_replace_all(alpha_string, "[^.0-9]", "")),
    alpha = ifelse(exclude_master, NA_real_, alpha_all)
  ) |>
  dplyr::select(doi,
                regex_label,
                exemplar, 
                alpha, 
                pre, 
                post, 
                all,
                regex_inclusion, 
                regex_exclusion,
                location_start, 
                location_end,
                location_alpha_start,
                location_alpha_end,
                alpha_string,
                alpha_all,
                substring_between_cronbach_and_estimate,
                substring_immediately_before_estimate,
                substring_a_bit_before_estimate,
                substring_immediately_after_estimate,
                substring_a_bit_after_estimate,
                exclude_master, 
                exclude_quant_comparison_present,
                exclude_comparison_present,
                exclude_comparison_present_immediately_before_estimate,
                exclude_comparison_present_immediately_after_estimate,
                exclude_comparison_present_after_estimate,
                exclude_cutoff_present,
                exclude_range_present,
                exclude_nonalphas_present,
                exclude_non_cron_mention_after_estimate,
                exclude_non_cron_mention_before_estimate,
                exclude_significance_present,
                exclude_doi_present,
                exclude_CI,
                exclude_psychometrika_present,
                exclude_odd_string_present,
                exclude_kappa,
                exclude_s) |>
  arrange(doi, regex_label) %>% 
  mutate(location_alpha_absolute = location_end + location_alpha_start - 1)

```

## Exclusions

```{r}

data_estimates_after_exclusions <- data_estimates |>
  distinct(doi, 
           alpha_string, 
           location_alpha_absolute, 
           .keep_all = TRUE)

```

# Extract test type

psycTests includes information about whether the DOI included an original scale, a revision, a translation, or a subtest. Extract this information to recombine it it with the extracted estimates later.

```{r}

data_test_type <- records_wide |>
  rename(doi = DOI) |>
  distinct(doi, test_type)

```

# Combine

```{r}

data_processed <- data_estimates_after_exclusions |>
  left_join(data_test_type, by = "doi") |>
  # select cols of interest + rename
  select(doi, test_type, exemplar, alpha, 
         # alpha_all,
         extracted_text = all, regex_label, regex_inclusion, regex_exclusion, 
         #alpha_location_in_text = location_alpha_absolute, 
         starts_with("exclude"))

data_processed |>
  count(test_type) |>
  arrange(desc(n))

```

## Write to disk

```{r}

dir.create("../../data/processed/psycTests")

write_rds(data_processed, "../../data/processed/psycTests/data_processed_psyctests.rds",
          compress = "gz")

write_csv(data_processed, "../../data/processed/psycTests/data_processed_psyctests.csv")

```


